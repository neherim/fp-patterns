#+REVEAL_EXTRA_CSS: ./css/local.css
#+REVEAL_TRANS: fade
#+REVEAL_THEME: moon
#+REVEAL_PLUGINS: (notes)
#+REVEAL_DEFAULT_FRAG_STYLE: roll-in
#+OPTIONS: toc:nil num:nil reveal_slide_number:nil author:nil date:nil timestamp:nil
#+OPTIONS: reveal_width:1200 reveal_height:800
#+TITLE: Introduction to Functional Programming pt. 3

* Learn Haskell in 10 minutes
#+BEGIN_NOTES
Haskell чистый функциональный язык программирования общего назначения c ленивой моделью вычисления.
Ленивый - означает, что любые значения вычисляются только когда они нужны
Чистый - означает, что все функции в хаскеле чистые, то есть не производят никаких сторонних эфектов

Это кажется немного старнным, как же без сторонних эффектов и изменения
состояния написать хоть сколько нибудь осмысленну программу?

Если проводить параллели с языком Java, то можно воспользоваться следующей интуицией:
Представим, что у нас все переменные стали final, а структуры иммутабельными.
Все операции связанные с вводом/выводом возвращают значения, обернутые в Future
(причем такие Future, которые не запускаются при создании).
То есть, например, мы обращаемся к БД и получаем не ResultSet, а
`Future<ResultSet>`. И так с любой IO операцией.
В дополнение к этому, мы не можем получить значение из этой Future, то есть у
этой Future нет метода `.get()`
Только сама jvm в `main` методе может получить значение из этой Future.
И единственное что нам остается, пытаться композировать все эти Future в одну
Future и возвращать ее в `main` методе, который уже ее запустит.

При таких ограничениях получается что наша программа - это одно большое
выражение, которое возвращает Future. А эта Future является композицией других Future.
Таким образом мы достигаем чистоты функций так, как никаких сайд эфектов при
вызове функций не происходит.

Ленивость языка проявляется в том, что все вычисления производятся только тогда,
когда их результат потребуется.
#+END_NOTES

** Lists
#+attr_reveal: :frag (roll-in)
#+begin_src haskell
"Hello" ++ ", World!" -- "Hello world!"
#+end_src

#+attr_reveal: :frag (roll-in)
#+begin_src haskell
[1..5] == [1, 2, 3, 4, 5]
#+end_src

#+attr_reveal: :frag (roll-in)
#+begin_src haskell
['A'..'F'] == "ABCDEF"
#+end_src

#+attr_reveal: :frag (roll-in)
#+begin_src haskell
[1..]
#+end_src

#+attr_reveal: :frag (roll-in)
#+begin_src haskell
[1..3] ++ [4..6] -- [1, 2, 3, 4, 5, 6]
#+end_src

#+attr_reveal: :frag (roll-in)
#+begin_src haskell
1 : [2, 3, 4] -- [1, 2, 3, 4]
#+end_src

#+attr_reveal: :frag (roll-in)
#+begin_src haskell
[x*2 | x <- [1..5]] -- [2, 4, 6, 8, 10]
#+end_src

#+attr_reveal: :frag (roll-in)
#+begin_src haskell
[(x, y) | x <- [1..3], y <- [1..3], x + y > 4] -- [(2,3), (3,2), (3,3)]
#+end_src


** Functions

#+attr_reveal: :frag (roll-in)
#+begin_src haskell
add :: Integer -> Integer -> Integer
add a b = a + b
#+end_src

#+attr_reveal: :frag (roll-in)
#+begin_src haskell
add 1 3 -- 4
#+end_src

#+attr_reveal: :frag (roll-in)
#+begin_src haskell
addOne = add 1 -- :: Integer -> Integer

addOne 4 -- 5
#+end_src

#+attr_reveal: :frag (roll-in)
#+begin_src haskell
main :: IO ()
main = putStrLn "Hello, World!"
#+end_src


** Controls
#+attr_reveal: :frag (roll-in)
#+begin_src haskell
factorial :: Integer -> Integer
factorial n = if n < 2
              then 1
              else n * factorial (n - 1)
#+end_src

#+attr_reveal: :frag (roll-in)
#+begin_src haskell
factorial :: Integer -> Integer
factorial 0 = 1
factorial n = n * factorial (n - 1)
#+end_src


* FP Patterns
#+BEGIN_NOTES
Functional programming design patterns by Scott Wlaschin (Скотт Влашин)
Функциональное программирование часто критикуют за использование математического
жаргона. Термины вроде зигохистоморфный препроморфизм конечно не помогают
продавать ФП.
Если посмотреть на паттерны ООП, то названия будут более привычными для нас
"Мост, Визитор, SOLID", но сами эти понятия довольно размытые.

В ФП паттерны имеют под собой математическую основу со своими законами, в ООП же
любой паттерн можно реализовать множеством способов и это не будет ошибкой.
#+END_NOTES

#+BEGIN_LEFTCOL
 * Semigroup
 * Monoid
 * Functor
 * Monad
 * Catamorphism
#+END_LEFTCOL

#+BEGIN_RIGHTCOL
#+attr_reveal: :frag (roll-in)
 * Appendable
 * Aggregatable
 * Mappable
 * Chainable
 * Collapsable
#+END_RIGHTCOL


* Semigroup
#+BEGIN_NOTES
Полугруппа в общей алгебре — множество с заданной на нём ассоциативной бинарной операцией
#+END_NOTES

#+REVEAL: split
$$
(G, \cdot  : G \times  G \rightarrow  G)\\
(x \cdot y) \cdot z = x \cdot (y \cdot z)
$$

#+REVEAL: split
#+begin_src haskell
class Semigroup a where
  (<>) :: a -> a -> a
#+end_src

#+attr_reveal: :frag (roll-in)
#+begin_src haskell
(x <> y) <> z = x <> (y <> z)
#+end_src


* TODO Monoid
#+BEGIN_NOTES
Моноид — полугруппа с нейтральным элементом.
Более подробно, моноидом называется множество M, на котором задана бинарная
ассоциативная операция, обычно именуемая умножением, и в котором существует
такой элемент e, который удоволетворяет следующему равенству.

Поскольку бинарная операция принимает два занчения одного типа и в качестве
результата возвращает значение того же типа, то это позволяет нам легко строить
композицию моноидов.
Мы можем из двух моноидов получить один состовной, потом добавить к нему третий
и так далее до бесконечности. Моноид как паттерн позволяет нам собрать что-то
сложное из простых частей.

Ассоциативность этой операции позволяет нам разделить применение этой операции
по разным потокам или даже разным сервисам
#+END_NOTES

#+REVEAL: split
$$
(G, \cdot  : G \times  G \rightarrow  G)\\
(x \cdot y) \cdot z = x \cdot (y \cdot z)\\
e \cdot x = x \cdot e = x
$$

#+REVEAL: split
#+begin_src haskell
class Semigroup a => Monoid a where
  mempty  :: a
#+end_src


* TODO Functor
#+BEGIN_NOTES
Функтор — особый тип отображений между категориями. Его можно понимать как
отображение, сохраняющее структуру.
#+END_NOTES


* TODO Monad

#+REVEAL_EXTRA_CSS: ./css/local.css
#+REVEAL_TRANS: fade
#+REVEAL_THEME: moon
#+REVEAL_PLUGINS: (notes highlight)
#+REVEAL_HIGHLIGHT_CSS: https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.10/build/styles/solarized-dark.min.css
#+REVEAL_DEFAULT_FRAG_STYLE: roll-in
#+OPTIONS: toc:nil num:nil reveal_slide_number:nil author:nil date:nil timestamp:nil
#+OPTIONS: reveal_width:1200 reveal_height:800
#+TITLE: Functional Programming Patterns

* Learn Haskell in 10 minutes
#+BEGIN_NOTES
Haskell чистый функциональный язык программирования общего назначения c ленивой моделью вычисления.
Ленивый - означает, что любые значения вычисляются только когда они нужны
Чистый - означает, что все функции в хаскеле чистые, то есть не производят никаких сторонних эфектов

Это кажется немного старнным, как же без сторонних эффектов и изменения
состояния написать хоть сколько нибудь осмысленну программу?

Если проводить параллели с языком Java, то можно воспользоваться следующей интуицией:
Представим, что у нас все переменные стали final, а структуры иммутабельными.
Все операции связанные с вводом/выводом возвращают значения, обернутые в Future
(причем такие Future, которые не запускаются при создании).
То есть, например, мы обращаемся к БД и получаем не ResultSet, а
`Future<ResultSet>`. И так с любой IO операцией.
В дополнение к этому, мы не можем получить значение из этой Future, то есть у
этой Future нет метода `.get()`
Только сама jvm в `main` методе может получить значение из этой Future.
И единственное что нам остается, пытаться композировать все эти Future в одну
Future и возвращать ее в `main` методе, который уже ее запустит.

При таких ограничениях получается что наша программа - это одно большое
выражение, которое возвращает Future. А эта Future является композицией других Future.
Таким образом мы достигаем чистоты функций так, как никаких сайд эфектов при
вызове функций не происходит.

Ленивость языка проявляется в том, что все вычисления производятся только тогда,
когда их результат потребуется.
#+END_NOTES
** Lists
#+attr_reveal: :frag (roll-in)
#+begin_src haskell
"Hello" ++ ", World!" -- "Hello world!"
#+end_src

#+attr_reveal: :frag (roll-in)
#+begin_src haskell
[1..5] == [1, 2, 3, 4, 5]
#+end_src

#+attr_reveal: :frag (roll-in)
#+begin_src haskell
['A'..'F'] == "ABCDEF"
#+end_src

#+attr_reveal: :frag (roll-in)
#+begin_src haskell
[1..]
#+end_src

#+attr_reveal: :frag (roll-in)
#+begin_src haskell
[1..3] ++ [4..6] -- [1, 2, 3, 4, 5, 6]
#+end_src

#+attr_reveal: :frag (roll-in)
#+begin_src haskell
1 : [2, 3, 4] -- [1, 2, 3, 4]
#+end_src

#+attr_reveal: :frag (roll-in)
#+begin_src haskell
[x*2 | x <- [1..5]] -- [2, 4, 6, 8, 10]
#+end_src

#+attr_reveal: :frag (roll-in)
#+begin_src haskell
[(x, y) | x <- [1..3], y <- [1..3], x + y > 4] -- [(2,3), (3,2), (3,3)]
#+end_src

** Functions

#+attr_reveal: :frag (roll-in)
#+begin_src haskell
add :: Integer -> Integer -> Integer
add a b = a + b
#+end_src

#+attr_reveal: :frag (roll-in)
#+begin_src haskell
add 1 3 -- 4
#+end_src

#+attr_reveal: :frag (roll-in)
#+begin_src haskell
addOne = add 1 -- :: Integer -> Integer

addOne 4 -- 5
#+end_src

#+attr_reveal: :frag (roll-in)
#+begin_src haskell
main :: IO ()
main = putStrLn "Hello, World!"
#+end_src

** Controls
#+attr_reveal: :frag (roll-in)
#+begin_src haskell
factorial :: Integer -> Integer
factorial n = if n < 2
              then 1
              else n * factorial (n - 1)
#+end_src

#+attr_reveal: :frag (roll-in)
#+begin_src haskell
factorial :: Integer -> Integer
factorial 0 = 1
factorial n = n * factorial (n - 1)
#+end_src

** TODO Data

* Patterns
#+BEGIN_NOTES
Функциональное программирование часто критикуют за использование математического
жаргона. Термины вроде зигохистоморфный препроморфизм конечно не помогают
продавать ФП. Если посмотреть на паттерны ООП, то названия будут более
привычными для нас "Мост, Визитор, SOLID", но в тоже время сами эти понятия
довольно размытые.

В ФП паттерны имеют под собой математическую основу со своими законами, в ООП же
любой паттерн можно реализовать множеством способов и это не будет ошибкой.
#+END_NOTES

#+BEGIN_LEFTCOL
 * Semigroup
 * Monoid
 * Functor
 * Monad
 * Catamorphism
#+END_LEFTCOL

#+BEGIN_RIGHTCOL
#+attr_reveal: :frag (roll-in)
 * Appendable
 * Aggregatable
 * Mappable
 * Chainable
 * Collapsable
#+END_RIGHTCOL

* Semigroup


#+BEGIN_SRC java
public static void main(String[] args) {
    Config configFromArgs = fromArgs(args);

    startApplication(configFromArgs);
}


#+END_SRC

#+BEGIN_SRC java
public static void main(String[] args) {
    Config configFromArgs = fromArgs(args);
    Config configFromFile = fromFile("config.yml");

    startApplication(configFromArgs);
}

#+END_SRC

#+BEGIN_SRC java
public static void main(String[] args) {
    Config configFromArgs = fromArgs(args);
    Config configFromFile = fromFile("config.yml");

    Config config = compose(configFromFile, configFromArgs);
    startApplication(config);
}
#+END_SRC

#+REVEAL: split
#+BEGIN_NOTES
Конфиг в примере выше можно заменить на получение и композицию метрик с разных
сервисов или соединение логов с нескольких серверов. Объединяет их одно -
функция композиции, со следующей сигнатурой:
#+END_NOTES

#+BEGIN_SRC haskell
a -> a -> a
#+END_SRC

#+BEGIN_NOTES
Функция принимает два аргумента одного типа и возвращает результат того же типа
что и аргументы.
#+END_NOTES

#+REVEAL: split
#+BEGIN_NOTES
Теперь давайте познакомимся поближе с этими паттернами, начнем с
полугрупп. Приготовьтесь, сейчас будет немного математики.
#+END_NOTES

#+attr_reveal: :frag (roll-in)
2 + 3 = 5

#+attr_reveal: :frag (roll-in)
(2 + 3) + 6 = 2 + (3 + 6)
#+BEGIN_NOTES
Если к 2 прибавить 3, то получится 5. Сложение ассоциативно, то есть порядок
вычислений не важен.
В принципе это вся математика, которая нам нужна для понимания полугрупп.
Дадим формальное определение.
Полугруппа в общей алгебре — множество с заданной на нём ассоциативной бинарной
операцией.
#+END_NOTES

#+REVEAL: split
$$
(G, \cdot  : G \times  G \rightarrow  G)\\
(x \cdot y) \cdot z = x \cdot (y \cdot z)
$$

#+REVEAL: split
#+BEGIN_NOTES
Теперь попробуем представить полгруппу в виде Java интерфейса
#+END_NOTES
#+BEGIN_SRC java
public interface Semigroup<A> {
    A apply(A a, A b);
}
#+END_SRC

#+BEGIN_NOTES
И теперь тоже самое в Haskell:
#+END_NOTES
#+attr_reveal: :frag (roll-in)
#+BEGIN_SRC haskell
class Semigroup a where
  (<>) :: a -> a -> a
#+END_SRC

#+REVEAL: split
#+BEGIN_NOTES
Теперь приведем несколько примеров полугрупп.
Первый пример: строки и операция конкатенации.
#+END_NOTES
#+BEGIN_SRC java
static class StringSemigroup implements Semigroup<String> {
    public String apply(String x, String y) {
        return x + y;
    }
}
#+END_SRC

#+attr_reveal: :frag (roll-in)
#+BEGIN_SRC java
StringSemigroup ss = new StringSemigroup();
ss.apply("Hello", ss.apply(" ", "World"));
#+END_SRC

#+REVEAL: split
#+BEGIN_NOTES
Тоже самое на Haskell
#+END_NOTES
#+BEGIN_SRC haskell
instance Semigroup String where
  (<>) = (++)
#+END_SRC

#+attr_reveal: :frag (roll-in)
#+BEGIN_SRC haskell
"Hello" <> " " <> "World"
#+END_SRC

#+RESULTS:
: Prelude> "Hello World"

#+REVEAL: split
#+BEGIN_NOTES
Другой пример полугруппы - множество целых чисел и определенная на них операция
минимума:
#+END_NOTES
#+BEGIN_SRC java
class MinIntSemigroup implements Semigroup<Integer> {
    public Integer apply(Integer a, Integer b) {
        return a < b ? a : b;
    }
}
#+END_SRC

#+attr_reveal: :frag (roll-in)
#+BEGIN_SRC java
MinIntSemigroup ms = new MinIntSemigroup();
ms.apply(100, ms.apply(42, 512));
#+END_SRC


#+REVEAL: split
#+BEGIN_NOTES
Довольно легко написать функцию свертки на списке полугрупп. Со
следующей сигнатурой:
#+END_NOTES
#+BEGIN_SRC java
Optional<T> sconcat(Semigroup<T> semigroup, List<T> list)
#+END_SRC

#+BEGIN_SRC haskell
sconcat :: Semigroup a => [a] -> Maybe a
#+END_SRC

#+BEGIN_NOTES
Сразу бросается в глаза то что, такая функция вынуждена возвращать
Optional.empty(), в случае если мы передадим ей пустой список. В случае с
полугруппой с операцией минимум это оправдано, так как очевидно что ничего
осмысленного в случае с пустым списком мы вернуть не сможем. Но для полугруппы
суммы чисел мы бы хотели, чтобы такая функция вернула бы нам 0, а для строк -
пустую строку. Для этого нам нужно добавить к бинарной операции еще некий
нейтральный элемент и таким образом мы получаем моноид
#+END_NOTES

* Monoid
#+BEGIN_NOTES
Моноидом называется множество M, на котором задана бинарная ассоциативная
операция, и в котором существует нейтральный элемент e, удоволетворяющий
следующему равенству.
#+END_NOTES

$$
(G, \cdot  : G \times  G \rightarrow  G)\\
(x \cdot y) \cdot z = x \cdot (y \cdot z)\\
e \cdot x = x \cdot e = x
$$

#+REVEAL: split
#+BEGIN_SRC java
public interface Monoid<A> extends Semigroup<A> {
    A empty();
}
#+END_SRC

#+attr_reveal: :frag (roll-in)
#+BEGIN_SRC haskell
class Semigroup a => Monoid a where
  mempty  :: a
#+END_SRC

#+REVEAL: split
#+BEGIN_SRC java
class StringMonoid implements Monoid<String> {
    public String empty() { return ""; }
    public String apply(String a, String b) {
        return a + b;
    }
}
#+END_SRC

#+attr_reveal: :frag (roll-in)
#+BEGIN_SRC java
class IntSumMonoid implements Monoid<Integer> {
    public Integer empty() { return 0; }
    public Integer apply(Integer a, Integer b) {
        return a + b;
    }
}
#+END_SRC

#+attr_reveal: :frag (roll-in)
#+BEGIN_SRC java
class IntProdMonoid implements Monoid<Integer> {
    public Integer empty() { return 1; }
    public Integer apply(Integer a, Integer b) {
        return a * b;
    }
}
#+END_SRC

#+BEGIN_NOTES
Поскольку бинарная операция принимает два занчения одного типа и в качестве
результата возвращает значение того же типа, то это позволяет нам легко строить
композицию моноидов.
Мы можем из двух моноидов получить один состовной, потом добавить к нему третий
и так далее. И в результате мы все равно получим тот же самый моноид, готовый к
дальнейшей композиции. При этом мы остаемся в рамках одного и того же
типа.

Моноид как паттерн позволяет нам собрать что-то
сложное из простых частей не вводя каких-то дополнительных концепций.

Ассоциативность этой операции позволяет нам разделить применение этой операции
по разным потокам или даже разным сервисам


Примеры монойдов: отрезки на прямой, деньги, путь к файлу, права доступа к файлу.

В программировании мы постоянно имеем дело с моноидами. Например, строки и
операция сложения строк, целые числа и операция сложения и умножения, или даже
целые числа и операция выбора меньшего числа. Или операция композиция,
определенная на множестве эндоморфизмов (функции, у которых ввод и вывод —
одного типа.). Кажется что это все разные операции, но все это моноиды, давайте
попробуем обобщить это:
#+END_NOTES


#+REVEAL: split
#+BEGIN_SRC java
public static <T> T mconcat(Monoid<T> monoid, List<T> list)
#+END_SRC

#+BEGIN_SRC haskell
mconcat :: [a] -> a
#+END_SRC

#+BEGIN_NOTES
Замечательным примером являются списки. Два списка — предположим [1,2] и [3,4] —
могут быть объединены оператором \++ в единый список [1,2,3,4].
Существует также пустой список [], при комбинировании с которым мы получаем
второй список в неизменном виде —
например, []++[1,2,3,4]==[1,2,3,4].

Другим примером является тип целых чисел Integer. Два элемента — например,
3 и 4 — могут быть скомбинированы оператором +, давая в результате сумму — 7. У
нас также
есть элемент 0, при сложении с которым любое целое число остаётся неизменным.

Почему нам может понадобиться использовать mappend, когда мы уже имеем в наличии такие функции, как ++ и +?
Одна из причин заключается в том, что моноиды автоматически предоставляют еще
одну функцию — mconcat.
Эта функция принимает на вход список значений в моноиде и комбинирует их вместе.
Например, mconcat [a,b,c] будет эквивалентно
a `mappend` (b `mappend` c). Таким образом, в любом моноиде существует легкий
способ скомбинировать вместе
целый список. Стоит отметить, что в идее mconcat заключается некоторая
двусмысленность.
Какой порядок должен быть выбран, чтобы вычислить mconcat [a,b,...,c,d]? Должны
ли мы выполнять операции слева направо,
или начать с c `mappend` d? Здесь вступает в силу правило ассоциативности: порядок не имеет значения.
Моноиды также будут к месту, если вам необходимо, чтобы ваш код был применим вне
зависимости от способа комбинирования
элементов. Вы можете написать код, который подобно mconcat будет работать с любым моноидом.


Ranges
A range of numbers or a range of dates can be
seen as a monoid, for example with the
compact-union operation, and the empty range as
the neutral element:
 [1, 3] Union [2, 4] = [1, 4] // compact union
 [1, 3] Union ][ = [1, 3] // neutral element
By defining the operation of “compact” union:
public final class Range{
 private final int min;
 private final int max;
 public final static EMPTY = new Range();
 public Range union(Range other){
 return new Range(
 min(this.min, other.min),
 max(this.max,other.max));
 }
}
#+END_NOTES

* Functor
#+BEGIN_NOTES
Давайте поразмышляем над следущим кодом, в котором мы ищем клиента по имени, а
потом получаем город, в котором он живет.
#+END_NOTES

#+BEGIN_SRC java
Customer customer = findCustomerByName(name);
String city = customer.getAddress().getCity();
#+END_SRC

#+BEGIN_NOTES
У опытного Java программиста глядя на этот код наверняка возникнет вопрос, а что
вернет функция findCustomerByName если мы не найдем клиента? Нет ли в этом коде
NPE? Возвращать из функции null и надеяться, что вызывающий ее программист
проверит результат наивно, то же самое с RuntimeException. Остается два
варианта - использовать checked исключения, либо заставить проверять наличие
значения через возвращаемый тип.
#+END_NOTES

#+BEGIN_SRC java
Optional<Customer> customer = findCustomerByName(name);
Optional<String> city = customer
    .map(Customer::getAddress)
    .map(Address:getCity);
#+END_SRC

#+BEGIN_NOTES
По определению из математики функтор — особый тип отображений между категориями.
Его можно понимать как отображение, сохраняющее структуру.
#+END_NOTES

#+BEGIN_NOTES
По определению из математики функтор — особый тип отображений между категориями.
Его можно понимать как отображение, сохраняющее структуру.
#+END_NOTES

\begin{multline}
\shoveleft F : C \to D \\
\shoveleft X \in C \text{ assign an object } F(X) \in D \\
\shoveleft f : X \rightarrow Y \in C \text{ assign an arrow } F(f) : F(X) \rightarrow F(Y) \in D
\end{multline}

#+REVEAL: split
#+BEGIN_NOTES
В Java функтором называют структуру данных, которая инкапсулирует некоторое
значение и имеет метод map со следующей сигнатурой для трансформации этого
значения:
#+END_NOTES
#+BEGIN_SRC java
interface Functor<A> {
    <B> Functor<B> map(Function<A, B> fn);
}
#+END_SRC

#+BEGIN_NOTES
Функтор не отвечает на вопрос как значение в него попадает и как его достать,
все это детали реализации конкретных функторов. Единственный способ
взаимодействия с этим значением - это цепочки трансформаций при помощи функции
map.

В Haskell функтор определен следующем образом:
#+END_NOTES
#+attr_reveal: :frag (roll-in)
#+BEGIN_SRC haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b
#+END_SRC
#+BEGIN_NOTES
Это можно прочитать следующим образом:
Тип f принадлежит к классу типов функтор, если для него определена функция fmap,
у которой первый параметр - это функция, принимающая значения типа a и
возвращающая значение типа b, второй параметр - это f параметризованный типом a
и результат - f, параметризованный типом b.

Тип f b - это тип высшего порядка. В Java, это было бы что-то
вроде: F<B>, то есть любой контейнер, который содержит тип B. Таким образом мы
бы получили возможность абстрагироваться не только от типа внутри контейнеров,
но и от типов самих контейнеров. Но к сожалению в Java так сделать нельзя (но
можно сделать в Scala)
#+END_NOTES

** Laws
#+BEGIN_NOTES
Но этого недостаточно, чтобы определить функтор. Как и в случае с моноидом
функтор должен удовлетворять некоторым законам, которые мы не можем выразить в
языках вроде Java или Haskell. Вот эти законы:
#+END_NOTES

\begin{multline}
\shoveleft f : X \rightarrow Y \in C, g : Y \rightarrow Z \in C \\
F(g \circ f) = F(g) \circ F(f) \\ \\
\shoveleft F(\text{id}_x)=\text{id}_{F(x)}
\end{multline}

#+REVEAL: split
#+BEGIN_NOTES
Запишем их в виде кода.
1. Вызов функции map с функцией identity должен вернуть тот же самый функтор:
#+END_NOTES
#+BEGIN_SRC java
functor.map(x -> x) == functor
#+END_SRC

#+BEGIN_NOTES
2. Закон композиции:
#+END_NOTES
#+attr_reveal: :frag (roll-in)
#+BEGIN_SRC java
opt.map(x -> String.valueOf(Math.round(x))) == opt.map(Math::round).map(String::valueOf)
#+END_SRC

#+BEGIN_NOTES
Смысл этих законов сводится к тому, что функция map не должна
менять структуру контейнера. Она должна взять содержимое контейнера, применить к
нему функцию, которую мы передали и завернуть результат в другой контейнер.
Исходный функтор при этом должен остаться неизменным.
#+END_NOTES
** Examles
#+BEGIN_NOTES
Функтор часто представляют как контейнер в котором содержится значение.
Рассмотрим самые распространенные примеры функторов.
#+END_NOTES

*** Optional/Maybe
#+BEGIN_NOTES
Optional это тип данных, который может либо содержать значение, либо нет.
Реализация функции map в этом случае довольно проста. В случае если Optional
пуст - возвращаем пустой Optional. Если значение присутствует - применяем к
нему переданную функцию и возвращаем новый экземпляр Optional с
трансформированным значением.
#+END_NOTES

#+BEGIN_SRC java
class Optional<T> implements Functor<T> {
    private final T value;

    private Optional(T value) {
        this.value = value;
    }

    @Override
    public <R> Optional<R> map(Optional<T, R> f) {
        if (value == null)
            return empty();
        else
            return of(f.apply(value));
    }

    public static <T> Optional<T> of(T a) {
        return new Optional<T>(a);
    }

    public static <T> Optional<T> empty() {
        return new Optional<T>(null);
    }
}
#+END_SRC

#+attr_reveal: :frag (roll-in)
#+BEGIN_SRC java
Optional<Customer> customer = findCustomerByName(name);
Optional<String> city = customer
    .map(Customer::getAddress)
    .map(Address:getCity);
#+END_SRC

#+REVEAL: split
#+BEGIN_SRC haskell
Maybe a = Nothing | Just a
#+END_SRC

#+attr_reveal: :frag (roll-in)
#+BEGIN_SRC haskell
instance Functor Maybe where
    fmap _ Nothing   = Nothing
    fmap f (Just a)  = Just (f a)
#+END_SRC

*** List
#+BEGIN_NOTES
Функтор не обязан содержать только одно значение, например список также является
функтором. Сигнатура функции map остается прежней, но ее поведение меняется. В
случае списка map применяет функцию трансформации к каждому элементу, возвращая
новый список.
#+END_NOTES
#+BEGIN_SRC java
class FList<T> extends ArrayList<T> implements Functor<T> {

    @Override
    public <R> FList<R> map(Function<T, R> f) {
        FList<R> result = new FList<>();
        for (int i = 0; i < size(); i++) {
            R newElement = f.apply(get(i));
            result.add(newElement);
        }
        return result;
    }
}
 #+END_SRC

#+attr_reveal: :frag (roll-in)
#+BEGIN_SRC java
FList<Customer> customers = getAllCustomers();
FList<String> cities = customers
    .map(Customer::getAddress)
    .map(Address:getCity);
#+END_SRC

*** Future/Task/Promise
#+BEGIN_NOTES
Определение функтора не накладывает никаких ограничений ни на структуру
контейнера, ни на то как значение в него попадает или как его достать от туда. Функтор
вообще может не содержать никакого значения в данный момент, а получать его
позже. Например, функтор можно имплементировать для класса Future<T>. При
создании объекта Future<T> в нем нет никакого значения, оно там появится когда
завершиться какое-то действие. Выполнится http запрос к внешнему
сервису или чтение из БД. Но это не мешает нам применять
трансформации к этому еще не полученному
значению через функцию map, так же как мы делали это с List и Optional. При этом
функция map не блокирует поток, ожидая появления значения. Таким образом мы можем
строить цепочки неблокирующих вычислений.
#+END_NOTES
#+BEGIN_SRC java
class Promise<T> implements Functor<T> {
    public <R> Promise<R> map(Function<T, R> f) { ... }
}
#+END_SRC

#+attr_reveal: :frag (roll-in)
#+BEGIN_SRC java
Promise<Customer> customer = customerServiceApi.getCustomerById(id);
Promise<String> city = customer
    .map(Customer::getAddress)
    .map(Address:getCity);
#+END_SRC

#+BEGIN_NOTES
По приведенным выше примерам функторов можно заметить на сколько это мощная
абстаркция. Мы использовали один и тот же api для реализации цепочки отложенных
вычислений, трансформации всех элементов списка и работы с неопределенным значением.

В этом и есть сила паттернов ФП. Простые, но мощные
абстракции, которые однозначно описываются в коде, со строго определенными
законами и вытекающими из них характеристиками.

В отличае от паттернов ООП, которые скорее похожи на сборник бабушкиных
рецептов, где количество ингридиентов обычно определяется на глаз и по вкусу.
#+END_NOTES


#+BEGIN_SRC haskell
data Either a b = Left a | Right b
#+END_SRC

#+BEGIN_SRC haskell
instance Functor (Either a) where
    fmap _ (Left x)   = Left x
    fmap f (Right y)  = Right (f y)
#+END_SRC

#+REVEAL: split
#+BEGIN_NOTES
Функтор очень мощная абстракция, но иногда ее мощности не хватает. Рассмотрим
пример, когда функция трансформации уже сама возвращает функтор вместо
трансформированного значения.
#+END_NOTES


#+BEGIN_SRC java
Optional<Manager> findLocalManager(String city) { ... }

//...
Optional<Customer> customer = findCustomerByName(name);
Optional<String> city = customer
    .map(Customer::getAddress)
    .map(Address:getCity);





#+END_SRC

#+BEGIN_NOTES
Если мы как раньше воспользуемся функцией map, то в результате получим тип
Optional<Optional<Manager>> с которым потом не понятно что делать.
#+END_NOTES

#+REVEAL: split
#+BEGIN_SRC java
Optional<Manager> findLocalManager(String city) { ... }

//...
Optional<Customer> customer = findCustomerByName(name);
Optional<Optional<Manager>> manager = customer
    .map(Customer::getAddress)
    .map(Address:getCity)
    .map(city -> findLocalManager(city));




#+END_SRC

#+BEGIN_NOTES
Можно явно проверять наличие значения в Optional, но такой вариант также не
отличается изяществом.
#+END_NOTES

#+REVEAL: split
#+BEGIN_SRC java
Optional<Manager> findLocalManager(String city) { ... }

//...
Optional<Customer> customer = findCustomerByName(name);
Optional<String> city = customer
    .map(Customer::getAddress)
    .map(Address:getCity);

Optional<Manager> manager = Optional.empty();
if (city.isPresent()) {
    manager = findLocalManager(city.get());
}
#+END_SRC

#+REVEAL: split
#+BEGIN_NOTES
Функция map из определения функтора имеет следующую сигнатуру:
#+END_NOTES

#+BEGIN_SRC haskell
(a -> b) -> f a -> f b
#+END_SRC

#+BEGIN_NOTES
Нам же нужна функция со следующей сигнатурой:
#+END_NOTES

#+attr_reveal: :frag (roll-in)
#+BEGIN_SRC haskell
(a -> f b) -> f a -> f b
#+END_SRC

#+BEGIN_NOTES
Функцию с такой сигнатурой мы найдем в классе типов монада
#+END_NOTES

* TODO Monad

#+BEGIN_NOTES
Монада над категорией {\displaystyle K}K — это моноид в моноидальной категории
эндофункторов {\displaystyle \mathrm {End} (K)}{\mathrm {End}}(K).

Монада — это общий способ описать идею последовательных вычислений, которые
можно соединять вместе так, чтобы от результата предыдущего вычисления зависело
следующее.

С точки зрения программирования монада это тип данных с одним параметром,
обладающим двумя функциями: Функцией конструктором (unit/pure/return), которая
оборачивает некоторое значение в монаду. И функцией связывания (flatMap/bind).
Как и рассмотренные ранее паттерны монада должна удоволетворять некоторым
законам

Интерфейс Monad может выглядет на Java следующим образом:
#+END_NOTES

#+BEGIN_SRC java
public interface Monad<T, M extends Monad<?, ?>> extends Functor<T> {
    M flatMap(Function<T, M> f);
}
#+END_SRC

#+BEGIN_NOTES
Попробуем написать имплиментацию этого интерфейса для Optional
#+END_NOTES

#+attr_reveal: :frag (roll-in)
#+BEGIN_SRC java
class Optional<T> implements Monad<T, Optional<T>> {
    private final T value;

    private Optional(T value) {
        this.value = value;
    }

    public static <T> Optional<T> of(T a) {
        return new Optional<>(a);
    }

    public static <T> Optional<T> empty() {
        return new Optional<>(null);
    }

    @Override
    public <B> Optional<B> map(Function<T, B> fn) {
        if (value == null)
            return empty();
        else
            return of(fn.apply(value));
    }

    @Override
    public Optional<T> flatMap(Function<T, Optional<T>> fn) {
        if (value == null)
            return empty();
        else
            return fn.apply(value);
    }
}
#+END_SRC

#+BEGIN_NOTES
Вернемся к нашему примеру, где мы хотели найти менеджера для клиента.
#+END_NOTES

#+REVEAL: split
#+BEGIN_SRC java
Optional<Manager> findLocalManager(String city) { ... }

//...
Optional<Customer> customer = findCustomerByName(name);
Optional<Optional<Manager>> manager = customer
    .map(Customer::getAddress)
    .map(Address:getCity)
    .map(city -> findLocalManager(city));
#+END_SRC

#+BEGIN_NOTES
Теперь мы можем переписать его  следующим образом:
#+END_NOTES

#+REVEAL: split
#+BEGIN_SRC java
Optional<Manager> findLocalManager(String city) { ... }

//...
Optional<Customer> customer = findCustomerByName(name);
Optional<Manager> manager = customer
    .map(Customer::getAddress)
    .map(Address:getCity)
    .flatMap(city -> findLocalManager(city));
#+END_SRC


#+REVEAL: split
#+BEGIN_SRC haskell
class Functor m => Monad m where
    (>>=)   :: m a -> (a -> m b) -> m b

    pure    :: a -> m a
#+END_SRC

#+attr_reveal: :frag (roll-in)
#+BEGIN_SRC haskell
instance Monad Maybe where
    (Just x) >>= k      = k x
    Nothing  >>= _      = Nothing

    pure x = Just x
#+END_SRC

#+BEGIN_NOTES
Показать как можно добраться до вложенного опшина.
Для хаскеля монады жизненнеобоходимы, через них делается IO
Это единственный способ выстроить последовательность вызовов функций в ленивом языке


https://www.nurkiewicz.com/2016/06/functor-and-monad-examples-in-plain-java.html


В Java много классов, представляющих отложенные вычисления: Future Java 1.5,
Guava Future, CompletableFuture из Java 8, ListenableFuture из Spring и Guava и
еще десятки менее популярных реализаций.


Promise<BigDecimal> discount =
    loadCustomer(42)
        .flatMap(this::readBasket)
        .flatMap(b -> calculateDiscount(b, DayOfWeek.FRIDAY));



This becomes interesting. flatMap() must preserve monadic type therefor
all intermediate objects are Promises. It is not just about keeping the
types in order - preceding program is suddenly fully asynchronous!
loadCustomer() returns a Promise so it does not block. readBasket()
takes whatever the Promise has (will have) and applies a function
returning another Promise and so on and so forth. Basically we built an
asynchronous pipeline of computation where the completion of one step in
background automatically triggers next step.

#+END_NOTES

* TODO Pattrens composition
#+BEGIN_NOTES
Так же можно построить полезные связи между различными функциональными
паттернами. Например, Maybe (или его аналог в Java - Optional) так же является
моноидом, в случае если его параметр типа - полугруппа. Реализация функции
mappend и mempty в данном случае довольно банальна
#+END_NOTES
#+BEGIN_SRC haskell
instance Semigroup a => Monoid (Maybe a) where
    Nothing <> b       = b
    a       <> Nothing = a
    Just a  <> Just b  = Just (a <> b)

    mempty = Nothing
#+END_SRC

#+BEGIN_NOTES
Благодаря этому можно легко композировать занчения Maybe не заботясь о наличие
или отсутствии в них значений. Например так:
#+END_NOTES

#+BEGIN_SRC haskell
(Just "Hello") <> (Just " ") <> (Just "World!")
#+END_SRC

#+RESULTS:
: Prelude> Just "Hello World"


#+BEGIN_NOTES
TODO может стоит привести пример монады writer или Validation с накопление ошибки
#+END_NOTES


* End
#+BEGIN_NOTES
Абстракции крайне важны. В принципе все чем мы занимаемся в программировании -
это проектирование абстракций и взаимодействий между ними. К признакам хороших
абстракций можно отнести возможность комбинировать их друг с другом и
универсальность, то есть количество разных вещей, которые можно выразить через
абстракцию.

У математиков очень большой опыт в построении и использовании абстракций. И
поскольку язык Хаскелл был разработан математиками, то нет ничего удивительного
что в нем используются знакомые математикам и проверенные временем абстракции. И
дальше они уже потихоньку протекают в мейнстрим языки программирования.
#+END_NOTES

* Trash

\begin{multline}
\shoveleft F : C \to D \\
\shoveleft X \in C \text{ assign an object } F(X) \in D \\
\shoveleft f : X \rightarrow Y \in C
\text{ assign an arrow } F(f) : F(X) \rightarrow F(Y) \in D
\end{multline}


#+attr_reveal: :frag (roll-in)
\begin{multline}
\shoveleft f : X \rightarrow Y \in C, g : Y \rightarrow Z \in C \\
F(g \circ f) = F(g) \circ F(f) \\ \\
\shoveleft F(\text{id}_x)=\text{id}_{F(x)}
\end{multline}
